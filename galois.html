<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galois Field Table p^n</title>
    <style>
        table {
            border-collapse: collapse;
            margin-top: 20px;
            margin-right: 20px;
            float: left;
        }
        td, th {
            border: 1px solid black;
            width: 30px;
            height: 30px;
            text-align: center;
        }
        th {
            background-color: #f0f0f0;
        }
        .axis {
            background-color: #e0e0e0;
        }
        .clear {
            clear: both;
        }
    </style>
</head>
<body>

    <h2>Galois Field Table Builder</h2>

    <!-- Поля ввода для p, n и выбора корня -->
    <label for="p">Enter p:</label>
    <input type="number" id="p" min="1" value="3"><br><br>

    <label for="n">Enter n:</label>
    <input type="number" id="n" min="1" value="2"><br><br>

    <button id="calcRoots">Find roots</button>
    <label for="root">Select root:</label>
    <select id="root"></select><br><br>

    <!-- Кнопки -->

    <button id="buildTable">Build Table</button>
    <button id="clearTable">Clear Table</button>
    <div id="coordinate-planes"></div>

<script type="module">
import { GaloisField } from './galoisField.js';

var galoisField;

function createMultipleTables(n, data) {
    const dimensions = data.length > 0 ? data[0].coords.length : 2; // Количество измерений
    const container = document.getElementById('coordinate-planes');

    // Получаем максимальные значения для всех координат кроме X и Y
    let maxCoords = Array(n).fill(0);

    // Определяем максимальные значения для каждой координаты после x и y
    data.forEach(item => {
        for (let i = 2; i < dimensions; i++) {
            maxCoords[i - 2] = maxCoords[i - 2] >= item.coords[i] ? maxCoords[i - 2] : item.coords[i];
            // maxCoords[i - 2] = Math.max(maxCoords[i - 2], Number(item.coords[i]));
        }
    });

    // Для каждой комбинации координат за пределами x и y создаём отдельную таблицу
    const createTableForCoords = (remainingCoords, currentLevel) => {
        if (currentLevel >= maxCoords.length) {
            // Создаем таблицу для фиксированного уровня координат
            const table = document.createElement('table');
            const caption = document.createElement('caption');
            caption.innerHTML = `( ${remainingCoords.map((val, index) => `${val}`).join(', ')} )`;
            table.appendChild(caption);
    
            for (let i = n; i >= 0; i--) {
                const row = document.createElement('tr');
    
                for (let j = 0n; j <= n; j++) {
                    const cell = document.createElement(i == 0 || j == 0 ? 'th' : 'td');
                    // const cell = document.createElement('td');
    
                    if (i == 0 && j == 0) {
                        cell.innerHTML = ' ';
                    } else if (i == 0) {
                        // Ось x
                        cell.innerHTML = j - 1n;
                        cell.classList.add('axis');
                    } else if (j == 0) {
                        // Ось y
                        cell.innerHTML = i - 1n;
                        cell.classList.add('axis');
                    } else {
                        // Ищем объект с координатами x, y и фиксированными оставшимися координатами
                        const obj = data.find(item => {
                            const [x, y, ...rest] = item.coords;
                            return x == j - 1n && y == i - 1n && rest.every((coord, index) => coord == remainingCoords[index]);
                            return x == j - 1n && y == i - 1n && rest.every((coord, index) => coord == remainingCoords[index]);
                        });
                        cell.innerHTML = obj ? obj.number : '∞';
                    }
    
                    row.appendChild(cell);
                }
    
                table.appendChild(row);
            }

            container.appendChild(table);
        } else {
            // Рекурсивно создаём таблицы для всех значений текущей координаты
            for (let i = 0; i <= maxCoords[currentLevel]; i++) {
                createTableForCoords([...remainingCoords, i], currentLevel + 1);
            }
        }
    };

    // Запуск генерации таблиц для всех возможных комбинаций координат за пределами x и y
    createTableForCoords([], 0);
}

function calcRoots() {
    const p = BigInt(parseInt(document.getElementById('p').value));
    const n = BigInt(parseInt(document.getElementById('n').value));

    galoisField = new GaloisField(p, n);
    galoisField.findRoots();

    // Заполняем список выбора корней
    const rootSelect = document.getElementById('root');
        rootSelect.innerHTML = '';
        galoisField.roots.forEach((root, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.text = `${root.toString()}`;
            rootSelect.appendChild(option);
    });
}

function buildTable() {
    clearTable();

    const selectedRoot = galoisField.linOps[parseInt(document.getElementById('root').value)];

    galoisField.buildFromMatrix(selectedRoot);
    createMultipleTables(galoisField.p, galoisField.field);
}

function clearTable() {
    const table = document.getElementById('coordinate-planes');
    table.innerHTML = '';
}

document.getElementById('calcRoots').addEventListener('click', calcRoots);
document.getElementById('buildTable').addEventListener('click', buildTable);
document.getElementById('clearTable').addEventListener('click', clearTable);
</script>

</body>
</html>
